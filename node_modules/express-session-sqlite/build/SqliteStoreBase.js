"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqliteStoreBase = void 0;
const sqlite_1 = require("sqlite");
const path_1 = require("path");
const SQL = require('sql-template-strings');
const debug = require('debug')('express-session-sqlite');
class SqliteStoreBase {
    constructor(config) {
        this.hasInit = false;
        this.config = config;
        this.prefix = config.prefix || '';
        this.db = null;
    }
    getSid(sid) {
        return this.prefix + sid;
    }
    async init() {
        if (!this.db) {
            if (!this.config.driver) {
                throw new Error('express-session-sqlite: driver not defined');
            }
            if (!this.config.path) {
                throw new Error('express-session-sqlite: path not defined');
            }
            debug('Opening sqlite database');
            this.db = await (0, sqlite_1.open)({
                filename: this.config.path,
                driver: this.config.driver
            });
            debug('Running migrations for the session table');
            await this.db.migrate({
                migrationsPath: (0, path_1.join)(__dirname, 'migrations')
            });
            this.hasInit = true;
        }
    }
    async get(sid) {
        debug(`Getting session: ${sid}`);
        await this.init();
        const time = new Date().getTime();
        const resp = await this.db.get(SQL `SELECT * FROM sessions WHERE sid = ${this.getSid(sid)} AND ${time} < expires`);
        if (!resp) {
            return null;
        }
        debug(`Session found: ${sid}`);
        return JSON.parse(resp.data);
    }
    async set(sid, session) {
        await this.init();
        const serialized = JSON.stringify(session);
        const msTtl = new Date().getTime() + this.config.ttl;
        debug(`Setting session: ${sid}`);
        const stmt = await this.db.prepare('REPLACE INTO sessions (sid, data, expires) VALUES (:sid, :data, :expires)', {
            ':sid': this.getSid(sid),
            ':data': serialized,
            ':expires': msTtl
        });
        await stmt.run();
    }
    async destroy(sid) {
        await this.init();
        debug(`Destroying session: ${sid}`);
        await this.db.run(SQL `DELETE FROM sessions WHERE sid = ${this.getSid(sid)}`);
    }
    async all() {
        await this.init();
        const time = new Date().getTime();
        debug(`Fetching all sessions`);
        const data = await this.db.all(`SELECT * FROM sessions WHERE ${time} < expires`);
        return data.map(raw => {
            return JSON.parse(raw.data);
        });
    }
    async length() {
        await this.init();
        const time = new Date().getTime();
        debug(`Getting session counts`);
        const data = await this.db.get(`SELECT count(*) as total FROM sessions WHERE ${time} < expires`);
        return data.total;
    }
    async clear() {
        await this.init();
        debug(`Clearing all sessions`);
        await this.db.run(`DELETE FROM sessions`);
    }
    async touch(sid, session) {
        debug(`Refreshing session: ${sid}`);
        await this.init();
        await this.set(sid, session);
        debug(`Refresh session complete: ${sid}`);
    }
    /**
     * Have to manually call this to remove stale entries
     */
    async removeExpiredSessions() {
        await this.init();
        const time = new Date().getTime();
        debug(`Removing expired sessions`);
        await this.db.run(`DELETE FROM sessions WHERE ${time} > expires`);
    }
}
exports.SqliteStoreBase = SqliteStoreBase;
//# sourceMappingURL=SqliteStoreBase.js.map